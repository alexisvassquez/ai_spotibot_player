# AudioScript Live EBNF Grammar Spec (v0.2-dev)
#
# WHAT THIS IS
# ------------
# AudioScript Live is the *human-first* language used for live coding
# music logic during playback (or rehearsal). It is designed to be:
#   - readable, minimal, and expressive
#   - safe to interpret/compile while the engine is running
#   - easy to author by humans (not just generated by the AudioMIX system)
#
# WHAT THIS IS NOT
# ----------------
# AudioScript Live is NOT the engineâ€™s primary execution format.
# We intentionally separate the language into two layers:
#
#   1) AudioScript Live  (this file)
#      - written/edited by humans
#      - supports reactive hooks (e.g., on mood("hype") { ... })
#      - supports FX chaining via `with`
#      - supports `let` bindings for reuse
#
#   2) AudioScript IR (Intermediate Representation) 
#      - generated by the compiler/analyzers/AI/export tooling
#      - engine-executable, deterministic, schedulable (timeline/at/section)
#      - designed for long-term stability + versioning
#      - please refer to AudioScriptIR.ebnf file in this directory for more info
#
# WHY TWO LAYERS
# --------------
# Live code and deterministic playback have fundamentally different needs:
#   - Live is interactive and optimized for quick edits + performance
#   - IR is explicit and optimized for scheduling + repeatability
#
# This split keeps the Creative Operating Layer (COL) clean:
#   - the engine runs a stable contract (IR)
#   - the Live syntax can evolve without breaking projects
#   - COL is AudioMIX DSP system
#
# SEMANTICS (HIGH-LEVEL)
# ----------------------
# - A Script is a sequence of Statements.
# - Statements may be:
#   - comments (ignored by the compiler/runtime)
#   - let assignments (bind an Identifier to an Expression)
#   - function calls (engine commands / high-level actions)
#   - blocks (reactive hooks driven by runtime events)
#
# EVENT BLOCKS
# ------------
# Block syntax:
#   on mood("hype") { ... }
#   on track("cvltiv8r_clean") { ... }
#
# Semantics:
# - EventHooks do not "run immediately" in isolation.
# - They are registered as handlers and executed when the event fires.
# - These blocks are ideal for performance logic and AI-driven triggers.
#
# FUNCTION CALLS + FX CHAINING
# ----------------------------
# FunctionCall syntax:
#   cmd(arg1, arg2, ...) with fx1 + fx2 + fx3
#
# Semantics:
# - `with` describes a post-processing chain or modifier pipeline.
# - The compiler typically lowers a `with` chain into a sequence of IR/COL
#   commands (or attaches metadata to a command group).
# - FXName is currently Identifier-only (no args in v0.2-dev).
#
# LET + EXPRESSIONS
# -----------------
# Assignment syntax:
#   let name = Expression
#
# Expression options (v0.2-dev):
#   - FunctionCall
#   - ListLiteral
#   - Identifier
#
# Note:
# - Numbers in this grammar are currently integers only (no decimals).
#   IR supports floats; Live to be expanded later. TODO
# - ListLiterals are intended for simple collections like:
#     let bands = ["bass_boost", "treble_cut"]
#
# PARSING / TOOLING NOTES
# -----------------------
# - EmptyLine is a placeholder production (currently matches nothing).
#   Some parsers treat blank lines as whitespace and never emit EmptyLine.
# - This EBNF is a spec. The actual AudioScript compiler may implement additional
#   whitespace rules, newlines, or error recovery strategies.
#
# VERSIONING / FUTURE EXPANSION
# -----------------------------
# v0.2-dev is intentionally minimal.
# Expected future expansions include:
#   - float numbers in Live (e.g., 0.30, -3.0)
#   - named arguments (e.g., intensity: 0.30)
#   - richer FX nodes with parameters (fx.reverb(room=0.8))
#   - additional EventHooks (beat/bar cues, transport state, audience input)

Script        = { Statement } ;

Statement     = Comment | Assignment | FunctionCall | Block | EmptyLine ;
Comment       = "#", { any character except line break } ;
EmptyLine     = ;

Assignment    = "let", Identifier, "=", Expression ;

Block         = "on", EventHook, "{" , { Statement }, "}" ;
EventHook     = "mood" , "(", String, ")" 
              | "track" , "(", String, ")" ;

FunctionCall  = Identifier, "(", [ ArgumentList ], ")", [ WithClause ] ;
ArgumentList  = Argument, { ",", Argument } ;
Argument      = String | Number | Identifier ;

WithClause    = "with", FXChain ;
FXChain       = FXName, { "+", FXName } ;
FXName        = Identifier ;

Expression    = FunctionCall 
              | ListLiteral 
              | Identifier ;

ListLiteral   = "[", [ ListElement, { ",", ListElement } ], "]" ;
ListElement   = String | Number ;

Identifier    = letter, { letter | digit | "_" } ;
String        = '"', { any character except '"' }, '"' ;
Number        = digit, { digit } ;

letter        = "A".."Z" | "a".."z" ;
digit         = "0".."9" ;
